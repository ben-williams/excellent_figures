\documentclass[11pt,letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage{wrapfig}
\usepackage[hidelinks]{hyperref}
\usepackage{subfig}
\usepackage[left=1.00in, right=1.00in, top=1.00in, bottom=1.00in]{geometry}

\author{Ben Williams\\bcwilliams@alaska.gov}
\date{}
\title{Most excellent figures in R with ggplot2}
\begin{document}
	\maketitle
\tableofcontents
\section{Short version}
Set up the R work environment to produce publication quality documents using ggplot. Use theme\_set and ggsave to increase dpi from base R level (72 dpi), also allows for defining figure dimensions.

Load packages
<<load,message=FALSE,warning=FALSE, eval=FALSE>>=
library(extrafont)
#font_import() only do this one time - it takes a while
loadfonts(device="win")
windowsFonts(Times=windowsFont("TT Times New Roman"))

library(ggplot2)
theme_set(theme_bw(base_size=12,base_family='Times New Roman')+ 
  theme(panel.grid.major = element_blank(),
  panel.grid.minor = element_blank()))
@ 

<<one, eval=FALSE>>=
ggplot(data, aes(x=x, y=y))+geom_point()
ggsave("filename.png", dpi=300, height=4, width=4, units="in")
@

\newpage
%\begin{multicols}{2}
\section{Basics}
\subsection{ggplot base figure}
You say you want to create a publication quality figure using ggplot? Well then, you are in the right place!
First, let's look at what ggplot produces as a base graphic. We will use the R built in data set \textit{mtcars}.

<<base,fig.height=4, fig.width=4, eval=FALSE>>=
library(ggplot2)
ggplot(mtcars, aes(wt, mpg))+geom_point()
@

We get a gray background with small black dots, white grid lines, and a font that is not particularly legible when the figure is placed in this document (Figure 1a). Most journals require a figure to be 300 dpi or greater not to mention the background should be white, without grid lines, and with a font that is consistent with the rest of the manuscript. Lets address these step by step.
\subsection{White background}
Want a white background? We've got that. Simply add a \textit{theme} to the figure (Figure 1b).

<<wht,fig.height=4, fig.width=4,eval=FALSE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+theme_bw()
@

\subsection{Remove grid lines}
To remove grid lines add another \textit{theme} (Figure 1c).

<<grid,fig.height=4, fig.width=4,eval=FALSE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+theme_bw()+
  theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
@


\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{0.49\textwidth}
		<<base0, fig.align='left',echo=FALSE, dpi=300, dev='png'>>=
library(ggplot2)
ggplot(mtcars, aes(wt, mpg))+geom_point()
@
\caption{Base graphic}
\end{subfigure}%
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.49\textwidth}
   	<<base1, fig.align='left',echo=FALSE, dpi=300, dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+theme_bw()
@
\caption{White background}
	\end{subfigure}
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.49\textwidth}
      <<base2, fig.align='center',echo=FALSE, dpi=300, dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+theme_bw()+
  theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
@
\caption{White background, no grid lines}
	\end{subfigure}
	\caption{Remove the base color and grid lines from ggplot.}\label{fig:clear}
\end{figure}



\subsection{Fonts and resolution}
Fonts are both easy and not so easy to deal with depending on what your needs are. In this case we want a Times New Roman 12 pt font. The 12 pt is easy so let's start with that.

Simply add a base\_size option in theme\_bw() as seen in (Figure~2a). 
<<font, out.width=".49\\textwidth",fig.align='center',fig.cap="Font change first try",fig.pos='H', eval=FALSE, dpi=300, dev='png'>>=
ggplot(mtcars, aes(wt, mpg)) + geom_point() +
  theme_bw(base_size=12) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
@

Hey nothing happened, this is the same as Figure 1c? 

The reason for this is the file size. These figures were saved as .png and R has a base figure output of 72 ppi. This resolution is too low for journal submissions so let's up it. 
In this case I'm outputting a .png file with a set width and height and a resolution of 300. In order to save the figure we will use \textit{ggsave} (Figure~2b).

<<gsave,eval=FALSE>>=
ggsave("figure2b.png", dpi=300, height=4, width=4, units="in")
@


\begin{figure}[H]
   \centering
	\begin{subfigure}[b]{0.49\textwidth}
<<font0, fig.align='left',echo=FALSE,, dpi=300, dev='png'>>=
library(ggplot2)
ggplot(mtcars, aes(wt, mpg))+geom_point()+
  theme_bw(base_size=12)+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
@
\caption{Change font?}
\end{subfigure}%
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.49\textwidth}
<<font1, fig.align='left',echo=FALSE,fig.height=4, dpi=300, fig.width=4,dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+
  theme_bw(base_size=12)+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
@
\caption{12pt font size}
	\end{subfigure}
	\caption{Change font and resolution.}\label{fig:clear}
\end{figure}



Our figure is looking ok, but the font is not correct. I'm on a Windows machine, so these procedures may be different for other operating systems. R is not terribly great at fonts so it is necessary to define the fonts clearly. This involves loading the \textit{extrafont} package, then importing and unpacking the fonts. \textit{Note: Only font\_import one time, it takes a while and once done you are good to go, I have it commented out as I've already run it}. 

<<fontfake, message=FALSE, warning=FALSE,  eval=FALSE, dpi=300, dev='png'>>=
library(extrafont)
#font_import()
loadfonts(device="win")
@
Load the fonts for a windows device and define the font for windows.
<<loadwin,eval=FALSE>>=
windowsFonts(Times=windowsFont("TT Times New Roman"))
@

Now the font can be incorporated into the figure via the theme\_bw() component (Figure~\ref{fig:font2}).
<<fakefig, eval=FALSE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+
  theme_bw(base_size=12,base_family='Times New Roman')+ 
  theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
@


<<font2, message=FALSE, warning=FALSE, echo=FALSE, cache=TRUE,fig.align='center',fig.height=4, dpi=300, fig.width=4,fig.cap="12 pt Time New Roman font figure.", fig.pos='H',dev='png'>>=
library(extrafont)
#font_import()
loadfonts(device="win")
windowsFonts(Times=windowsFont("TT Times New Roman"))
ggplot(mtcars, aes(wt, mpg))+geom_point()+
  theme_bw(base_size=12,base_family='Times New Roman')+ 
  theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
@

\subsection{A better way: theme\_set()}
While all these adjustments to ggplot are great, there is a much better way for defining all of your ggfigures. It goes by the name \textit{theme\_set}. Here is a working example.

<<update,warning=FALSE,error=FALSE,message=FALSE,dev='png',dpi=300>>=
library(extrafont);library(ggplot2)
#font_import() only do this one time - it takes a while
loadfonts(device="win")
windowsFonts(Times=windowsFont("TT Times New Roman"))
theme_set(theme_bw(base_size=12,base_family='Times New Roman')+
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()))

@

With the basic figure options set, less time is spent coding figures and more time can be spent exploring data. The code used to produce Figure~\ref{fig:font2} is now reduced to:
<<themeset,fig.pos='H',fig.height=4, dpi=300, fig.width=4, eval=FALSE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()
@

\section{Smoothers}
Lets explore these data, starting with a smooth. the base smooth for ggplot is ``loess" (Figure~4a) for data groups \textless1000 and a ``gam" for groups \textgreater1000 (Figure~4b).
<<message=FALSE, eval=FALSE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+geom_smooth()
@
\begin{figure}[H]
	\centering
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.45\textwidth}
<<loess,message=FALSE,fig.height=4, dpi=300, fig.width=4, echo=FALSE,dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+geom_smooth()
@
		\caption{Adding a loess smoother.}

	\end{subfigure}
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.45\textwidth}
<<gam,message=FALSE,fig.height=4, dpi=300, fig.width=4, message=FALSE, echo=FALSE, warning=FALSE,dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+geom_smooth(method='gam', formula=y~s(x))
@
		\caption{GAM smoother.}
	\end{subfigure}
	\caption{Adding smoothers (modeling).}\label{fig:font}
\end{figure}


That is great and all but most of us do not use loess on a regular basis. However we can also implement other model structures (Figure~\ref{fig:multi}). In this case we added a linear regression (\textit{lm}) and generalized linear regression with a polynomial (\textit{glm}), a generalized additive model with knots (\textit{k}) set at 5, and a non-linear least squares model. \textit{Note that the polynomial in the glm smooth could also be done via the \textit{lm} smooth (also with the poly function instead of the identity component), however I'm mostly showing that their is a \textit{glm} function that can be assigned different distributions (e.g., family=``binomial"), same goes for the \textit{gam} smoother. More info can be found here \url{http://www.ats.ucla.edu/stat/r/faq/smooths.htm}. Other good things can be found on that site as well}.
\clearpage
<<multi, message=FALSE,warning=FALSE,error=FALSE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Multiple smoothers.',dev='png',dpi=300>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+
  geom_smooth(alpha=.1)+geom_smooth(method='lm',alpha=.1, color=2, fill=2,)+ 
  geom_smooth(method='glm', alpha=.1, color=3, fill=3, formula=y~x+I(x^2))+
  geom_smooth(method='gam', alpha=.1, color=4, fill=4, formula=y~s(x, k=5))+
  geom_smooth(method = "nls", formula = 'y ~ a*x^2 + b*x +c',
    start=list(a=.1,b=.5,c=.2),se = FALSE, linetype = 1,
               colour = 5,fill=5, alpha=.1)
@



\section{Plot options}
\subsection{Point size \& color}
Want bigger points, no problem simply change the size in geom\_point() (Figure~\ref{fig:point}). Jitter using geom\_jitter(), etc.
<<point, message=FALSE,warning=FALSE,error=FALSE, fig.height=3.9,fig.width=4, fig.align='center', fig.cap='Point size.',dev='png' ,dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(size=4)+geom_smooth(alpha=.1)
@


However, if you want the points to be different colors this can be added to the aesthetic component (in either the ggplot() or geom\_point() component). For example lets change the size of the points by a car's horsepower (hp) a continuous variable in the dataframe (Figure~\ref{fig:color}. 

<<color, message=FALSE,warning=FALSE,error=FALSE, fig.height=3.9,fig.width=4, fig.align='center', fig.cap='Multiple smoothers.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)
@

Now the colors and sizes could be determined by changing hp to a factor (Figure 8a).
<<eval=FALSE, dpi=300, dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=factor(hp), color=factor(hp)))+
  geom_smooth(alpha=.1)

@

However this will often create too many discrete groups to clearly understand what is being plotted, therefore a ``better" method is to define the scales for the data points. This can be done with scale\_color\_gradientn() (Figure~8b).

<<eval=FALSE, dpi=300, dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5))+
  scale_size(range=c(0,7))
@

\begin{figure}[H]
	\centering
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.45\textwidth}
<<echo=FALSE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Multiple smoothers.',dev='png',dpi=300, fig.pos='H',cache=TRUE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=factor(hp), color=factor(hp)))+
  geom_smooth(alpha=.1)
@
		\label{fig:f10}
	\end{subfigure}
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.45\textwidth}
<<echo=FALSE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Multiple smoothers.',dev='png',dpi=300, fig.pos='H',cache=TRUE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5))+
  scale_size(range=c(0,7))
@
		\label{fig:f11}
	\end{subfigure}
	\caption{Adding smoothers (modeling).}\label{fig:font}
\end{figure}

\clearpage
Want to define where the legend breaks? no problem, just add a vector of values (Figure~\ref{fig:break}).

<<break,eval=TRUE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Multiple smoothers.',dev='png',dpi=300, fig.pos='H',cache=TRUE>>=

bs <- seq(0,350,25)
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7),breaks=as.vector(bs))
@

Note that the legend now falls off the plotted area for the figure. One way to fix this is to remove one of the legends, in this case the legend that references the size of the points (Figure~\ref{fig:combine}).

<<combine,echo=TRUE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Combine legends.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)
@


The legend now breaks in increments of 25 using a 5 color scale from the rainbow.

\subsection{Axis tickmarks}

It is quite easy to change the axis tick marks. Change the y-axis to every 5th value (Figure~\ref{fig:tick}).
<<tick,echo=TRUE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Change y-axis tick marks.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)+
  scale_y_continuous(breaks= seq(0,40,5))
@


Also change the x-axis, this time to unequal spacings (Figure~\ref{fig:tick2}).
<<tick2,echo=TRUE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Change y-axis and x-axis tick marks.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)+
  scale_y_continuous(breaks= seq(0,40,5))+
  scale_x_continuous(breaks= c(0,1,1.5,2,3,5))
@

Change the labels while keeping the tickmarks (Figure~\ref{fig:tick3}).
<<tick3,echo=TRUE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Change y-axis and x-axis tick marks.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)+
  scale_y_continuous(breaks= seq(0,40,5), labels=c(0,"",10,"",20,"",30,"",40))+
  scale_x_continuous(breaks= seq(0,5,.5), labels=c(seq(0,2,.5),"","",3.5, "",4.5,""))
@

However, the scale presented doesn't include zero, something that is often nice to have. The standard way to do this is to use xlim()and/or ylim().
<<zero,echo=FALSE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Change y-axis and x-axis tick marks.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)+
  scale_y_continuous(breaks= seq(0,40,5), labels=c(0,"",10,"",20,"",30,"",40))+
  scale_x_continuous(breaks= seq(0,5,.5), labels=c(seq(0,2,.5),"","",3.5, "",4.5,""))+
  xlim(0,5)+ylim(0,40)
@
A number of things have now changed, (1) the scales have reverted back to their original designations, (2) zero is now included on both axes, and (3) we have cut off data by constraining the axis at 5. One function of ggplot is that it only evaluates the data that is in the figure pane. So any smooths, etc., are informed only by the data that is seen. This can be changed to include the data in any smooth, but allow the figure to be ``zoomed in" on an area of interest. To do this we use coord\_cartesian() .
<<cartesian,echo=FALSE, fig.height=3.9,fig.width=4, fig.align='center', fig.cap='Combine legends.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+ 
  geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)+
  scale_y_continuous(breaks= seq(0,40,5), labels=c(0,"",10,"",20,"",30,"",40))+
  scale_x_continuous(breaks= seq(0,5,.5), labels=c(seq(0,2,.5),"","",3.5, "",4.5,""))+
  coord_cartesian(xlim=c(0,5),ylim=c(0,40))
@

The smooth now extends to the end of the pane as it indeed includes the values that are off the page. The points can be brought back into the figure by changing the x-axis limits.
<<xlimchange,echo=FALSE, fig.height=3.9,fig.width=4, fig.align='center', fig.cap='Combine legends.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+
  geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)+
  scale_y_continuous(breaks= seq(0,40,5), labels=c(0,"",10,"",20,"",30,"",40))+
  scale_x_continuous(breaks= seq(0,5,.5), labels=c(seq(0,2,.5),"","",3.5, "",4.5,""))+
  coord_cartesian(xlim=c(0,5.5),ylim=c(0,40))
@

\end{document}
