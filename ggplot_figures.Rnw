\documentclass[11pt,letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage{wrapfig}
\usepackage[hidelinks]{hyperref}
\usepackage{subfig}
\usepackage[left=1.00in, right=1.00in, top=1.00in, bottom=1.00in]{geometry}

\author{Ben Williams\\bcwilliams@alaska.gov}
\date{}
\title{Most excellent figures in R with ggplot2}
\begin{document}
	\maketitle
\tableofcontents
\section{Short version}
Set up the R work environment to produce publication quality documents using ggplot. Use theme\_set and ggsave to increase dpi from base R level (72 dpi), also allows for defining figure dimensions.

Load packages
<<load,message=FALSE,warning=FALSE, eval=FALSE>>=
library(extrafont)
#font_import() only do this one time - it takes a while
loadfonts(device="win")
windowsFonts(Times=windowsFont("TT Times New Roman"))

library(ggplot2)
theme_set(theme_bw(base_size=12,base_family='Times New Roman')+ 
  theme(panel.grid.major = element_blank(),
  panel.grid.minor = element_blank()))
@ 

<<one, eval=FALSE>>=
ggplot(data, aes(x=x, y=y))+geom_point()
ggsave("filename.png", dpi=300, height=4, width=4, units="in")
@


%\begin{multicols}{2}
\section{Basics}
\subsection{ggplot base figure}
You say you want to create a publication quality figure using ggplot? Well then, you are in the right place!
First, let's look at what ggplot produces as a base graphic. We will use the R built in data set \textit{mtcars}.

<<base,fig.height=4, fig.width=4, eval=FALSE>>=
library(ggplot2)
ggplot(mtcars, aes(wt, mpg))+geom_point()
@

We get a gray background with small black dots, white grid lines, and a font that is not particularly legible when the figure is placed in this document (Figure 1a). Most journals require a figure to be 300 dpi or greater not to mention the background should be white, without grid lines, and with a font that is consistent with the rest of the manuscript. Lets address these step by step.
\subsection{White background}
Want a white background? We've got that. Simply add a \textit{theme} to the figure (Figure 1b).

<<wht,fig.height=4, fig.width=4,eval=FALSE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+theme_bw()
@

\subsection{Remove grid lines}
To remove grid lines add another \textit{theme} (Figure 1c).

<<grid,fig.height=4, fig.width=4,eval=FALSE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+theme_bw()+
  theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
@


\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{0.49\textwidth}
		<<base0, fig.align='left',echo=FALSE, dpi=300, dev='png'>>=
library(ggplot2)
ggplot(mtcars, aes(wt, mpg))+geom_point()
@
\caption{Base graphic}
\end{subfigure}%
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.49\textwidth}
   	<<base1, fig.align='left',echo=FALSE, dpi=300, dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+theme_bw()
@
\caption{White background}
	\end{subfigure}
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.49\textwidth}
      <<base2, fig.align='center',echo=FALSE, dpi=300, dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+theme_bw()+
  theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
@
\caption{White background, no grid lines}
	\end{subfigure}
	\caption{Remove the base color and grid lines from ggplot.}\label{fig:clear}
\end{figure}



\subsection{Fonts and resolution}
Fonts are both easy and not so easy to deal with depending on what your needs are. In this case we want a Times New Roman 12 pt font. The 12 pt is easy so let's start with that.

Simply add a base\_size option in theme\_bw() as seen in (Figure~2a). 
<<font, out.width=".49\\textwidth",fig.align='center',fig.cap="Font change first try",fig.pos='H', eval=FALSE, dpi=300, dev='png'>>=
ggplot(mtcars, aes(wt, mpg)) + geom_point() +
  theme_bw(base_size=12) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
@

Hey nothing happened, this is the same as Figure 1c? 

The reason for this is the file size. These figures were saved as .png and R has a base figure output of 72 ppi. This resolution is too low for journal submissions so let's up it. 
In this case I'm outputting a .png file with a set width and height and a resolution of 300. In order to save the figure we will use \textit{ggsave} (Figure~2b).

<<gsave,eval=FALSE>>=
ggsave("figure2b.png", dpi=300, height=4, width=4, units="in")
@


\begin{figure}[H]
   \centering
	\begin{subfigure}[b]{0.49\textwidth}
<<font0, fig.align='left',echo=FALSE,, dpi=300, dev='png'>>=
library(ggplot2)
ggplot(mtcars, aes(wt, mpg))+geom_point()+
  theme_bw(base_size=12)+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
@
\caption{Change font?}
\end{subfigure}%
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.49\textwidth}
<<font1, fig.align='left',echo=FALSE,fig.height=4, dpi=300, fig.width=4,dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+
  theme_bw(base_size=12)+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
@
\caption{12pt font size}
	\end{subfigure}
	\caption{Change font and resolution.}\label{fig:clear}
\end{figure}



Our figure is looking ok, but the font is not correct. I'm on a Windows machine, so these procedures may be different for other operating systems. R is not terribly great at fonts so it is necessary to define the fonts clearly. This involves loading the \textit{extrafont} package, then importing and unpacking the fonts. \textit{Note: Only font\_import one time, it takes a while and once done you are good to go, I have it commented out as I've already run it}. 

<<fontfake, message=FALSE, warning=FALSE,  eval=FALSE, dpi=300, dev='png'>>=
library(extrafont)
#font_import()
loadfonts(device="win")
@
Load the fonts for a windows device and define the font for windows.
<<loadwin,eval=FALSE>>=
windowsFonts(Times=windowsFont("TT Times New Roman"))
@

Now the font can be incorporated into the figure via the theme\_bw() component (Figure~\ref{fig:font2}).
<<fakefig, eval=FALSE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+
  theme_bw(base_size=12,base_family='Times New Roman')+ 
  theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
@


<<font2, message=FALSE, warning=FALSE, echo=FALSE, cache=TRUE,fig.align='center',fig.height=4, dpi=300, fig.width=4,fig.cap="12 pt Time New Roman font figure.", fig.pos='H',dev='png'>>=
library(extrafont)
#font_import()
loadfonts(device="win")
windowsFonts(Times=windowsFont("TT Times New Roman"))
ggplot(mtcars, aes(wt, mpg))+geom_point()+
  theme_bw(base_size=12,base_family='Times New Roman')+ 
  theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
@

\subsection{A better way: theme\_set()}
While all these adjustments to ggplot are great, there is a much better way for defining all of your ggfigures. It goes by the name \textit{theme\_set}. Here is a working example.

<<update,warning=FALSE,error=FALSE,message=FALSE,dev='png',dpi=300>>=
library(extrafont);library(ggplot2)
#font_import() only do this one time - it takes a while
loadfonts(device="win")
windowsFonts(Times=windowsFont("TT Times New Roman"))
theme_set(theme_bw(base_size=12,base_family='Times New Roman')+
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()))

@

With the basic figure options set, less time is spent coding figures and more time can be spent exploring data. The code used to produce Figure~\ref{fig:font2} is now reduced to:
<<themeset,fig.pos='H',fig.height=4, dpi=300, fig.width=4, eval=FALSE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()
@

\section{Smoothers}
Lets explore these data, starting with a smooth. the base smooth for ggplot is ``loess" (Figure~4a) for data groups \textless1000 and a ``gam" for groups \textgreater1000 (Figure~4b).
<<message=FALSE, eval=FALSE>>=
options(scipen=3)
ggplot(mtcars, aes(wt, mpg))+geom_point()+geom_smooth()
@
\begin{figure}[H]
	\centering
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.45\textwidth}
<<loess,message=FALSE,fig.height=4, dpi=300, fig.width=4, echo=FALSE,dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+geom_smooth()
@
		\caption{Adding a loess smoother.}

	\end{subfigure}
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.45\textwidth}
<<gam,message=FALSE,fig.height=4, dpi=300, fig.width=4, message=FALSE, echo=FALSE, warning=FALSE,dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+geom_smooth(method='gam', formula=y~s(x))
@
		\caption{GAM smoother.}
	\end{subfigure}
	\caption{Adding smoothers (modeling).}\label{fig:font}
\end{figure}


That is great and all but most of us do not use loess on a regular basis. However we can also implement other model structures (Figure~\ref{fig:multi}). In this case we added a linear regression (\textit{lm}) and generalized linear regression with a polynomial (\textit{glm}), a generalized additive model with knots (\textit{k}) set at 5, and a non-linear least squares model. \textit{Note that the polynomial in the glm smooth could also be done via the \textit{lm} smooth (also with the poly function instead of the identity component), however I'm mostly showing that their is a \textit{glm} function that can be assigned different distributions (e.g., family=``binomial"), same goes for the \textit{gam} smoother. More info can be found here \url{http://www.ats.ucla.edu/stat/r/faq/smooths.htm}. Other good things can be found on that site as well}.
\clearpage
<<multi, message=FALSE,warning=FALSE,error=FALSE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Multiple smoothers.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point()+
  geom_smooth(alpha=.1)+geom_smooth(method='lm',alpha=.1, color=2, fill=2,)+ 
  geom_smooth(method='glm', alpha=.1, color=3, fill=3, formula=y~x+I(x^2))+
  geom_smooth(method='gam', alpha=.1, color=4, fill=4, formula=y~s(x, k=5))+
  geom_smooth(method = "nls", formula = 'y ~ a*x^2 + b*x +c',
    start=list(a=.1,b=.5,c=.2),se = FALSE, linetype = 1,
               colour = 5,fill=5, alpha=.1)
@



\section{Plot options}
\subsection{Point size \& color}
Want bigger points, no problem simply change the size in geom\_point() (Figure~\ref{fig:point}). Jitter using geom\_jitter(), etc.
<<point, message=FALSE,warning=FALSE,error=FALSE, fig.height=3.9,fig.width=4, fig.align='center', fig.cap='Point size.',dev='png' ,dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(size=4)+geom_smooth(alpha=.1)
@


However, if you want the points to be different colors this can be added to the aesthetic component (in either the ggplot() or geom\_point() component). For example lets change the size of the points by a car's horsepower (hp) a continuous variable in the dataframe (Figure~\ref{fig:color}. 

<<color, message=FALSE,warning=FALSE,error=FALSE, fig.height=3.9,fig.width=4, fig.align='center', fig.cap='Multiple smoothers.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)
@

Now the colors and sizes could be determined by changing hp to a factor (Figure 8a).
<<eval=FALSE, dpi=300, dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=factor(hp), color=factor(hp)))+
  geom_smooth(alpha=.1)

@

However this will often create too many discrete groups to clearly understand what is being plotted, therefore a ``better" method is to define the scales for the data points. This can be done with scale\_color\_gradientn() (Figure~8b).

<<eval=FALSE, dpi=300, dev='png'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5))+
  scale_size(range=c(0,7))
@

\begin{figure}[H]
	\centering
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.45\textwidth}
<<echo=FALSE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Multiple smoothers.',dev='png',dpi=300, fig.pos='H',cache=TRUE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=factor(hp), color=factor(hp)))+
  geom_smooth(alpha=.1)
@
		\label{fig:f10}
	\end{subfigure}
	~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
	%(or a blank line to force the subfigure onto a new line)
	\begin{subfigure}[b]{0.45\textwidth}
<<echo=FALSE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Multiple smoothers.',dev='png',dpi=300, fig.pos='H',cache=TRUE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5))+
  scale_size(range=c(0,7))
@
		\label{fig:f11}
	\end{subfigure}
	\caption{Adding smoothers (modeling).}\label{fig:font}
\end{figure}

\clearpage
Want to define where the legend breaks? no problem, just add a vector of values (Figure~\ref{fig:break}).

<<break,eval=TRUE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Multiple smoothers.',dev='png',dpi=300, fig.pos='H',cache=TRUE>>=

bs <- seq(0,350,25)
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7),breaks=as.vector(bs))
@

Note that the legend now falls off the plotted area for the figure. One way to fix this is to remove one of the legends, in this case the legend that references the size of the points (Figure~\ref{fig:combine}).

<<combine,echo=TRUE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Combine legends.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)
@


The legend now breaks in increments of 25 using a 5 color scale from the rainbow.

\subsection{Axis tickmarks}

It is quite easy to change the axis tick marks. Change the y-axis to every 5th value (Figure~\ref{fig:tick}).
<<tick,echo=TRUE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Change y-axis tick marks.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)+
  scale_y_continuous(breaks= seq(0,40,5))
@


Also change the x-axis, this time to unequal spacings (Figure~\ref{fig:tick2}).
<<tick2,echo=TRUE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Change y-axis and x-axis tick marks.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)+
  scale_y_continuous(breaks= seq(0,40,5))+
  scale_x_continuous(breaks= c(0,1,1.5,2,3,5))
@

Your collaborator really prefers to have all of the tick marks present so... Change the labels while keeping the tickmarks (Figure~\ref{fig:tick3}).
<<tick3,echo=TRUE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Change y-axis and x-axis tick marks.',dev='png',dpi=300, fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)+
  scale_y_continuous(breaks= seq(0,40,5), labels=c(0,"",10,"",20,"",30,"",40))+
  scale_x_continuous(breaks= seq(0,5,.5), labels=c(seq(0,2,.5),"","",3.5, "",4.5,""))
@

\clearpage
However, the scale presented doesn't include zero, something that is often nice to have. The standard way to do this is to use xlim()and/or ylim().
<<zero,echo=TRUE, fig.height=4,fig.width=4, fig.align='center', fig.cap='Change y-axis and x-axis tick marks.',dev='png',dpi=300, fig.pos='H',warning=FALSE>>=
ggplot(mtcars, aes(wt, mpg))+geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)+
  xlim(0,5)+ylim(0,40)
@
A number of things have now changed (Figure~\ref{fig:zero}), (1) the scales have reverted back to their original designations, (2) zero is now included on both axes, and (3) we have cut off data by constraining the axis at 5. One function of ggplot is that it only evaluates the data that is in the figure pane. So any smooths, etc., are informed only by the data that is seen. This can be changed to include the data in any smooth, but allow the figure to be ``zoomed in" on an area of interest. To do this we use coord\_cartesian()  (Figure~\ref{fig:cartesian}) .
<<cartesian,echo=TRUE, fig.height=3.9,fig.width=4, fig.align='center', fig.cap='Combine legends.',dev='png',dpi=300, fig.pos='H', fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+ 
  geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)+
  scale_y_continuous(breaks= seq(0,40,5), labels=c(0,"",10,"",20,"",30,"",40))+
  scale_x_continuous(breaks= seq(0,5,.5), labels=c(seq(0,2,.5),"","",3.5, "",4.5,""))+
  coord_cartesian(xlim=c(0,5),ylim=c(0,40))
@

The smooth now extends to the end of the pane as it indeed includes the values that are off the page. The points can be brought back into the figure by changing the x-axis limits (Figure~\ref{fig:xlimchange}.
<<xlimchange,echo=TRUE, fig.height=3.9,fig.width=4, fig.align='center', fig.cap='Combine legends.',dev='png',dpi=300, fig.pos='H', fig.pos='H'>>=
ggplot(mtcars, aes(wt, mpg))+
  geom_point(aes(size=hp, color=hp))+
  geom_smooth(alpha=.1)+
  scale_colour_gradientn(colours=rainbow(5), breaks=as.vector(bs))+
  scale_size(range=c(0,7), breaks=as.vector(bs),guide = FALSE)+
  scale_y_continuous(breaks= seq(0,40,5), labels=c(0,"",10,"",20,"",30,"",40))+
  scale_x_continuous(breaks= seq(0,5,.5), labels=c(seq(0,2,.5),"","",3.5, "",4.5,""))+
  coord_cartesian(xlim=c(0,5.5),ylim=c(0,40))
@

\section{Maps}
\subsection{Basic maps}
There are a number of ways in R to plot maps and deal with raster images etc. I have
no idea how to operate most of them. I do know a couple of easy ways to generate quick
images though, they are presented below. The easiest method is to simply call a Google map
location by name in ggmap. This needs an internet connection...
For this example (Figure~\ref{fig:ggmap}) I have called for a map of the Bering Sea, with a zoom of ``4"
(zoom needs to be an integer from 3 (continent) to 21 (building); more info here).

<<ggmap, message=FALSE, fig.height=4, fig.cap='A map of the Bering Sea, pulled directly from Google Maps via ggmap.',dev='png',dpi=300, fig.pos='H'>>=
library(ggmap)
bs <- get_map(location = "Bering Sea", zoom = 4)
ggmap(bs)
@



A map can be adjusted (centered) on a specific location (Figure~\ref{fig:ggmap1}), note that I changed
the ``zoom" on this map and used the longitude and latitude to determine the center of the
Figure. Points can be added easily, in the same manner as any other ggplot object.

\emph{Note: For this example I simply made up some points to place in the general location and
named them locs - you would have a separate dataframe with longitude and latitude positions
in it.}

First call the map.
<<ggmap1, message=FALSE, fig.height=4, fig.cap='A slightly zoomed in map of the Bering Sea, centered on specific coordinate locations.',dev='png',dpi=300, fig.pos='H',cache=TRUE>>=
bs1<-get_map(location = c(-170,63), zoom = 6)
@

Next add points to the map (Figure~\ref{fig:ggmap2}).
<<ggmap2, message=FALSE, fig.height=4, fig.cap='A slightly zoomed in map of the Bering Sea, centered on specific coordinate locations with randomly generated points overlayed.',dev='png',dpi=300, fig.pos='H', cache=TRUE>>=
locs<-data.frame(long=c(-172,-173,-170,-170.5,-170.52),lat=c(62.1,62.2,62.3,63,65))

ggmap(bs1)+geom_point(data=locs,aes(long,lat),size=5,color=4)
@



Polygons can be easily added in a manner similar to adding point locations. Here I've simply
made a polygon from the made-up database (Figure~\ref{fig:ggmap3}). You would have a separate database
holding the location for your polygon(s).

<<ggmap3,message=FALSE, fig.height=4, fig.cap='A slightly zoomed in map of the Bering Sea, centered on specific coordinate locations with a randomly generated polygon overlay.',dev='png',dpi=300, fig.pos='H',cache=TRUE>>=
ggmap(bs1)+geom_point(data=locs,aes(long,lat),size=5,color=4)+
    geom_polygon(aes(x = long, y = lat),data = locs,
    colour = NA, fill = "red", alpha = .5)
@  


\subsection{Going deeper into the mapping realm\\ 
(or the rabbit hole...)}
Mapping can get very confusing very quickly depending upon what exactly you want to do,
how you want to present information, etc. I am focusing on a limited subset of mapping,
mainly generating maps for quick visualization of data for evaluating spatial components.
There is a great deal of information on mapping using ggmap be sure to have a look. That
said sometimes you just want a shaded map or outline map minus the labels that are included
with the Google maps. This can be done as well!
Lets generate a map of the western Gulf of Alaska.
<<map1, message=FALSE, fig.height=4, fig.cap='A map of Alaska, based on data from worldHires in the maps package.',cache=TRUE, fig.pos='H',dpi=300,dev='png',cache=TRUE>>=
library(ggplot2)
library(maps)
library(mapdata)
library(mapproj)

ak<-map_data('worldHires','USA:Alaska')
ggplot()+geom_polygon(data=ak,aes(long,lat,group=group),fill=8,color="black")
@


Notice that this map doesn't seem quite right (Figure~\ref{fig:map1}), there are two ways to deal
with this one, if you don't need the far western Aleutian Islands you can simply constrain
the plot (that is the method I will present); two, if you do need the Aleutian Islands then
use ``world2Hires" as opposed to 'worldHires' for the data source, this centers the map on
the Pacific Ocean, but you will then have to deal with latitude and longitude adjustments
(longitude is no longer negative $\leftarrow$ small rabbit hole).

Lets return to the map we do want. There are two ways to constrain the data for the
Aleutians (remove it, or simply constrain the limits of the plot). The first method here
removes any points that are further west (east?) than 180$^o$. Then you can create a map
with a light grey fill for the land and a black outline for the coast (Figure~\ref{fig:map2}).

<<map2, message=FALSE, fig.height=5, fig.cap='ggplot2 map of Alaska based upon worldHires data.',cache=TRUE, fig.pos='H',dpi=300,dev='png',cache=TRUE>>=
ak<-map_data('worldHires','USA:Alaska')
ak<-subset(ak,long<0) #drop the end of the Aleutian Islands, or use world2Hires 
akmap<-ggplot()+geom_polygon(data=ak,aes(long,lat,group=group),fill=8,color="black")
akmap
@


Or we can simply constrain the data for the map if we are only interested in a particular
area of Alaska. We can also clean the map up while zooming into a particular areas (Figure~\ref{fig:map3}),
in this case the western Gulf of Alaska. Note that the code to zoom in is not simply done by
changing the x and y limits. When you constrain the x and y limits in ggplot it throws out
any data outside of the image, therefore the polygon shapes (``groups") will not be complete
and the image will not be pretty. In this plot I've incorporated the limits in
a projection wrapper (coord\_map), there are a number of different projections
that you can use though this will lead to a BIG rabbit hole!
I've added a background color (aliceblue) as well as incorporated degree symbols into the
x- and y-axis labels. Data points and polygons can now be added as additional layers as
shown earlier.
<<map3, message=FALSE, fig.height=4, fig.cap='ggplot2 map of Alaska based upon worldHires data all dressed up with color.',cache=TRUE, fig.pos='H',dpi=300,dev='png',cache=TRUE>>=
ak<-map_data('worldHires','USA:Alaska')
ggplot()+geom_polygon(data=ak,aes(long,lat,group=group),fill=8,color="black")+
    theme(panel.background=element_rect(fill='aliceblue'))+
    xlab(expression(paste(Longitude^o,~'W')))+
    ylab(expression(paste(Latitude^o,~'N')))+
    coord_map(xlim = c(-165, -145),ylim = c(54, 61))


@

 Figure~\ref{fig:map4} is the same map without color (better for reports, etc.).
<<map4,message=FALSE, fig.height=4, fig.cap='Zoomed in ggplot map of the western Gulf of Alaska based upon worldHires data.',dpi=300,dev='png',cache=TRUE, fig.pos='H',dpi=300,dev='png',cache=TRUE>>=
ggplot()+geom_polygon(data=ak,aes(long,lat,group=group),fill=8,color='black') +
   theme(panel.background=element_rect(fill='white')) + 
   xlab(expression(paste(Longitude^o,~'W'))) +
   ylab(expression(paste(Latitude^o,~'W')))+
    coord_map(xlim = c(-165, -145),ylim = c(54, 61)) 
@

\subsection{Bathymetry}

library(marmap)

#  Download data from the server
getNOAA.bathy(lon1=-175,lon2=-156,lat1=53,lat2=66, resolution=1) -> AKBath
#  Plot bathy data
plot(AKBath, image=T,xlim=c(-175,-156), ylim=c(53,66),las=1)
#  Ghetto low res AK map
map('worldHires',fill=T,xlim=c(-175,-156), ylim=c(53,66),add=T, col=8)
# Scale bar
scaleBathy(AKBath, deg=2, x="topleft", inset=5)
\end{document}


